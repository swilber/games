async function createPunchOutGame(settings, callbacks = null) {
    const gameArea = document.getElementById('game-area');
    
    // Load configuration
    let punchOutConfig = {};
    if (typeof configManager !== 'undefined') {
        punchOutConfig = await configManager.loadConfig('punchout');
    } else {
        punchOutConfig = {
            gameplay: settings,
            physics: settings,
            visual: settings,
            fighters: [
                { name: "Glass Joe", health: 60, speed: 0.8, patterns: ["jab"], tells: ["blink"] }
            ]
        };
    }
    
    // Game state
    let gameRunning = false;
    let gameWon = false;
    let gameStarted = false;
    let currentRound = 1;
    let roundTime = punchOutConfig.gameplay?.roundTime || 180;
    let currentFighter = 0;
    
    // Create canvas
    const canvas = document.createElement('canvas');
    canvas.width = punchOutConfig.physics?.canvasWidth || 800;
    canvas.height = punchOutConfig.physics?.canvasHeight || 600;
    const ctx = canvas.getContext('2d');
    
    // Game objects
    const player = {
        x: punchOutConfig.physics?.playerX || 400,
        y: punchOutConfig.physics?.playerY || 450,
        width: 60,
        height: 100,
        health: punchOutConfig.gameplay?.playerHealth || 100,
        maxHealth: punchOutConfig.gameplay?.playerHealth || 100,
        stamina: punchOutConfig.gameplay?.stamina || 100,
        maxStamina: punchOutConfig.gameplay?.stamina || 100,
        stars: 0,
        maxStars: punchOutConfig.gameplay?.maxStars || 3,
        blocking: false,
        dodging: null, // 'left', 'right', or null
        punching: false,
        punchType: null, // 'left', 'right', 'star'
        animationFrame: 0
    };
    
    const fighters = punchOutConfig.fighters || [
        { name: "Glass Joe", health: 60, speed: 0.8, patterns: ["jab"], tells: ["blink"] }
    ];
    
    const opponent = {
        x: punchOutConfig.physics?.opponentX || 400,
        y: punchOutConfig.physics?.opponentY || 200,
        width: 80,
        height: 120,
        health: fighters[currentFighter].health,
        maxHealth: fighters[currentFighter].health,
        name: fighters[currentFighter].name,
        speed: fighters[currentFighter].speed,
        patterns: fighters[currentFighter].patterns,
        tells: fighters[currentFighter].tells,
        currentPattern: 0,
        patternTimer: 0,
        tellTimer: 0,
        attacking: false,
        attackType: null,
        stunned: false,
        stunnedTimer: 0,
        animationFrame: 0
    };
    
    // Input handling
    const keys = {};
    
    function handleKeyDown(e) {
        keys[e.code] = true;
        
        if (!gameStarted) {
            gameStarted = true;
            if (callbacks && callbacks.onGameStart) {
                callbacks.onGameStart('punchout');
            }
        }
        
        if (!gameRunning) return;
        
        // Player controls
        switch(e.code) {
            case 'ArrowLeft':
                if (!player.punching && !player.blocking) {
                    player.dodging = 'left';
                }
                break;
            case 'ArrowRight':
                if (!player.punching && !player.blocking) {
                    player.dodging = 'right';
                }
                break;
            case 'ArrowDown':
                player.blocking = true;
                break;
            case 'KeyZ': // Left punch
                if (!player.blocking && !player.dodging && player.stamina > 10) {
                    player.punching = true;
                    player.punchType = 'left';
                    player.stamina -= 10;
                }
                break;
            case 'KeyX': // Right punch
                if (!player.blocking && !player.dodging && player.stamina > 10) {
                    player.punching = true;
                    player.punchType = 'right';
                    player.stamina -= 10;
                }
                break;
            case 'KeyC': // Star punch
                if (player.stars > 0 && !player.blocking && !player.dodging) {
                    player.punching = true;
                    player.punchType = 'star';
                    player.stars--;
                }
                break;
        }
    }
    
    function handleKeyUp(e) {
        keys[e.code] = false;
        
        switch(e.code) {
            case 'ArrowLeft':
            case 'ArrowRight':
                player.dodging = null;
                break;
            case 'ArrowDown':
                player.blocking = false;
                break;
        }
    }
    
    function update() {
        if (!gameRunning) return;
        
        // Update round timer
        roundTime -= 1/60;
        if (roundTime <= 0) {
            endRound();
            return;
        }
        
        // Update player
        updatePlayer();
        
        // Update opponent
        updateOpponent();
        
        // Check collisions
        checkCollisions();
        
        // Check win/lose conditions
        if (opponent.health <= 0) {
            winFight();
        } else if (player.health <= 0) {
            loseFight();
        }
    }
    
    function updatePlayer() {
        // Regenerate stamina
        if (player.stamina < player.maxStamina) {
            player.stamina += 0.5;
        }
        
        // Handle punch animation
        if (player.punching) {
            player.animationFrame++;
            if (player.animationFrame > 15) {
                player.punching = false;
                player.punchType = null;
                player.animationFrame = 0;
            }
        }
        
        // Handle dodge animation
        if (player.dodging) {
            player.animationFrame++;
            if (player.animationFrame > 20) {
                player.dodging = null;
                player.animationFrame = 0;
            }
        }
    }
    
    function updateOpponent() {
        if (opponent.stunned) {
            opponent.stunnedTimer--;
            if (opponent.stunnedTimer <= 0) {
                opponent.stunned = false;
            }
            return;
        }
        
        // AI pattern behavior
        opponent.patternTimer++;
        
        // Show tell before attacking
        if (opponent.patternTimer > 60 && opponent.patternTimer < 90) {
            opponent.tellTimer++;
        }
        
        // Execute attack
        if (opponent.patternTimer > 120) {
            if (!opponent.attacking) {
                const pattern = opponent.patterns[opponent.currentPattern];
                executeOpponentAttack(pattern);
                opponent.attacking = true;
            }
        }
        
        // Reset pattern
        if (opponent.patternTimer > 180) {
            opponent.patternTimer = 0;
            opponent.attacking = false;
            opponent.tellTimer = 0;
            opponent.currentPattern = (opponent.currentPattern + 1) % opponent.patterns.length;
        }
    }
    
    function executeOpponentAttack(pattern) {
        switch(pattern) {
            case 'jab':
                // Quick straight punch
                if (!player.blocking && !player.dodging) {
                    player.health -= 15;
                }
                break;
            case 'hook':
                // Side punch, can be dodged
                if (!player.blocking && player.dodging !== 'left') {
                    player.health -= 20;
                }
                break;
            case 'uppercut':
                // Powerful upward punch
                if (!player.blocking) {
                    player.health -= 25;
                }
                break;
            case 'rush':
                // Multiple quick punches
                if (!player.blocking && !player.dodging) {
                    player.health -= 10;
                }
                break;
        }
    }
    
    function checkCollisions() {
        if (player.punching && !opponent.stunned) {
            const playerPunchX = player.x + (player.punchType === 'left' ? -20 : 20);
            const playerPunchY = player.y - 20;
            
            // Check if punch hits opponent
            if (playerPunchX > opponent.x - opponent.width/2 && 
                playerPunchX < opponent.x + opponent.width/2 &&
                playerPunchY > opponent.y - opponent.height/2 &&
                playerPunchY < opponent.y + opponent.height/2) {
                
                let damage = 0;
                
                switch(player.punchType) {
                    case 'left':
                    case 'right':
                        damage = 10;
                        // Counter punch during tell gives star
                        if (opponent.tellTimer > 0) {
                            player.stars = Math.min(player.stars + 1, player.maxStars);
                            damage = 15;
                        }
                        break;
                    case 'star':
                        damage = 30;
                        opponent.stunned = true;
                        opponent.stunnedTimer = 120;
                        break;
                }
                
                opponent.health -= damage;
                opponent.health = Math.max(0, opponent.health);
            }
        }
    }
    
    function render() {
        // Clear canvas
        ctx.fillStyle = punchOutConfig.visual?.backgroundColor || '#000080';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw ring
        ctx.fillStyle = punchOutConfig.visual?.ringColor || '#8B4513';
        ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
        
        // Draw ropes
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 3;
        for (let i = 1; i <= 3; i++) {
            const y = canvas.height - 50 - (i * 100);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        
        // Draw opponent
        drawOpponent();
        
        // Draw player
        drawPlayer();
        
        // Draw UI
        drawUI();
    }
    
    function drawPlayer() {
        ctx.save();
        
        // Apply dodge offset
        let offsetX = 0;
        if (player.dodging === 'left') offsetX = -30;
        if (player.dodging === 'right') offsetX = 30;
        
        // Draw player body
        ctx.fillStyle = punchOutConfig.visual?.playerColor || '#FFE4B5';
        ctx.fillRect(player.x - player.width/2 + offsetX, player.y - player.height, 
                    player.width, player.height);
        
        // Draw gloves
        ctx.fillStyle = '#FF0000';
        if (player.punching) {
            if (player.punchType === 'left') {
                ctx.fillRect(player.x - 40 + offsetX, player.y - 60, 15, 15);
            } else if (player.punchType === 'right') {
                ctx.fillRect(player.x + 25 + offsetX, player.y - 60, 15, 15);
            }
        } else {
            ctx.fillRect(player.x - 35 + offsetX, player.y - 50, 12, 12);
            ctx.fillRect(player.x + 23 + offsetX, player.y - 50, 12, 12);
        }
        
        // Draw blocking stance
        if (player.blocking) {
            ctx.strokeStyle = '#FFFF00';
            ctx.lineWidth = 2;
            ctx.strokeRect(player.x - player.width/2 + offsetX, player.y - player.height, 
                          player.width, player.height);
        }
        
        ctx.restore();
    }
    
    function drawOpponent() {
        ctx.save();
        
        // Draw opponent body
        let opponentColor = punchOutConfig.visual?.opponentColor || '#D2691E';
        if (opponent.stunned) {
            opponentColor = '#FFFF00'; // Yellow when stunned
        }
        
        ctx.fillStyle = opponentColor;
        ctx.fillRect(opponent.x - opponent.width/2, opponent.y - opponent.height/2, 
                    opponent.width, opponent.height);
        
        // Draw opponent gloves
        ctx.fillStyle = '#000000';
        if (opponent.attacking) {
            ctx.fillRect(opponent.x - 20, opponent.y + 20, 15, 15);
            ctx.fillRect(opponent.x + 5, opponent.y + 20, 15, 15);
        } else {
            ctx.fillRect(opponent.x - 25, opponent.y, 12, 12);
            ctx.fillRect(opponent.x + 13, opponent.y, 12, 12);
        }
        
        // Draw tell indicator
        if (opponent.tellTimer > 0) {
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(opponent.x - 5, opponent.y - opponent.height/2 - 20, 10, 10);
        }
        
        ctx.restore();
    }
    
    function drawUI() {
        ctx.fillStyle = punchOutConfig.visual?.textColor || '#FFFFFF';
        ctx.font = '20px Arial';
        
        // Round info
        ctx.fillText(`Round ${currentRound}`, 20, 30);
        ctx.fillText(`Time: ${Math.ceil(roundTime)}`, 20, 55);
        
        // Fighter name
        ctx.fillText(opponent.name, canvas.width/2 - 60, 30);
        
        // Health bars
        drawHealthBar(20, 80, player.health, player.maxHealth, '#00FF00', 'Little Mac');
        drawHealthBar(20, 120, opponent.health, opponent.maxHealth, '#FF0000', opponent.name);
        
        // Stamina bar
        drawStaminaBar(20, 160, player.stamina, player.maxStamina);
        
        // Stars
        ctx.fillText(`Stars: ${'★'.repeat(player.stars)}`, canvas.width - 150, 30);
        
        // Controls
        ctx.font = '14px Arial';
        ctx.fillText('Z/X: Punch  C: Star Punch  ↓: Block  ←→: Dodge', 20, canvas.height - 20);
        
        // Win condition
        if (gameWon) {
            ctx.fillStyle = '#00FF00';
            ctx.font = '48px Arial';
            ctx.fillText('KNOCKOUT!', canvas.width/2 - 120, canvas.height/2);
        }
    }
    
    function drawHealthBar(x, y, health, maxHealth, color, label) {
        const width = 200;
        const height = 20;
        
        // Background
        ctx.fillStyle = '#333333';
        ctx.fillRect(x, y, width, height);
        
        // Health
        ctx.fillStyle = color;
        ctx.fillRect(x, y, (health / maxHealth) * width, height);
        
        // Border
        ctx.strokeStyle = '#FFFFFF';
        ctx.strokeRect(x, y, width, height);
        
        // Label
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '12px Arial';
        ctx.fillText(label, x, y - 5);
    }
    
    function drawStaminaBar(x, y, stamina, maxStamina) {
        const width = 200;
        const height = 15;
        
        // Background
        ctx.fillStyle = '#333333';
        ctx.fillRect(x, y, width, height);
        
        // Stamina
        ctx.fillStyle = '#FFFF00';
        ctx.fillRect(x, y, (stamina / maxStamina) * width, height);
        
        // Border
        ctx.strokeStyle = '#FFFFFF';
        ctx.strokeRect(x, y, width, height);
        
        // Label
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '12px Arial';
        ctx.fillText('Stamina', x, y - 5);
    }
    
    function startGame() {
        gameRunning = true;
        gameLoop();
    }
    
    function gameLoop() {
        if (gameRunning) {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
    }
    
    function winFight() {
        gameRunning = false;
        gameWon = true;
        
        setTimeout(() => {
            if (currentFighter < fighters.length - 1) {
                // Next fighter
                currentFighter++;
                resetForNextFighter();
            } else {
                // Won all fights
                if (callbacks && callbacks.onGameComplete) {
                    callbacks.onGameComplete('punchout', { completed: true });
                }
            }
        }, 2000);
    }
    
    function loseFight() {
        gameRunning = false;
        
        setTimeout(() => {
            // Restart current fight
            resetFight();
        }, 2000);
    }
    
    function endRound() {
        currentRound++;
        if (currentRound > 3) {
            // Decision - opponent wins on points
            loseFight();
        } else {
            // Next round
            roundTime = punchOutConfig.gameplay?.roundTime || 180;
            player.health = Math.min(player.maxHealth, player.health + 20);
            opponent.health = Math.min(opponent.maxHealth, opponent.health + 10);
        }
    }
    
    function resetForNextFighter() {
        currentFighter = Math.min(currentFighter, fighters.length - 1);
        const fighter = fighters[currentFighter];
        
        opponent.health = fighter.health;
        opponent.maxHealth = fighter.health;
        opponent.name = fighter.name;
        opponent.speed = fighter.speed;
        opponent.patterns = fighter.patterns;
        opponent.tells = fighter.tells;
        
        resetFight();
    }
    
    function resetFight() {
        currentRound = 1;
        roundTime = punchOutConfig.gameplay?.roundTime || 180;
        
        player.health = player.maxHealth;
        player.stamina = player.maxStamina;
        player.stars = 0;
        player.blocking = false;
        player.dodging = null;
        player.punching = false;
        
        opponent.currentPattern = 0;
        opponent.patternTimer = 0;
        opponent.tellTimer = 0;
        opponent.attacking = false;
        opponent.stunned = false;
        
        gameWon = false;
        gameRunning = true;
    }
    
    // Initialize game
    gameArea.innerHTML = '';
    gameArea.appendChild(canvas);
    
    // Add event listeners
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    
    // Start the game
    startGame();
    
    // Return game instance
    return {
        destroy: () => {
            gameRunning = false;
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            gameArea.innerHTML = '';
        }
    };
}
