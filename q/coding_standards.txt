# Coding Standards & Workflow
Last Updated: 2025-12-04T17:16:00.000-07:00

## MANDATORY: END-OF-SESSION ACCOUNTABILITY
**BEFORE responding "Changes pushed!" or completing any significant work:**
1. **STOP** - Review what was learned/discovered during this session
2. **UPDATE** relevant q/* files with new patterns, issues, or standards
3. **ADD** any new problems/solutions to common_issues.txt
4. **DOCUMENT** new coding patterns in coding_standards.txt
5. **REFRESH** session_log.txt with recent commands and learnings
6. **ONLY THEN** respond to user that work is complete

**This step is NOT optional - it must happen after every significant change.**

## CRITICAL: ALWAYS FOLLOW Q/* INSTRUCTIONS
- **READ ALL q/* files** before starting any work
- **UPDATE q/* files** when discovering new patterns or system requirements
- **PROVIDE COMPREHENSIVE TESTING INSTRUCTIONS** for every feature
- **FOLLOW session_log.txt maintenance** requirements strictly
- **ASSESS code quality** and prompt for refactoring opportunities

## Q FILE MAINTENANCE
- **Update these /q files regularly** as new patterns emerge
- **Remove outdated information** that no longer applies
- **Prioritize actionable information** over historical details
- **Add new files** if better organization is needed
- **Keep information current** and relevant to ongoing work
- **Update session_log.txt** with recent commands and context after significant work

## TESTING REQUIREMENTS
- **ALWAYS provide step-by-step testing instructions** for new features
- Include prerequisites, expected results, and edge cases
- Test both positive and negative scenarios
- Verify setting persistence and state management
- Document any special access requirements (debug mode, etc.)

## CODE QUALITY MONITORING
- **Check code_quality.txt regularly** for refactoring opportunities
- **Assess code smells** during development work
- **Prompt user for refactoring** when code becomes difficult to maintain
- **Monitor file sizes** and function complexity
- **Identify duplication** and suggest consolidation

## SESSION LOG MAINTENANCE
- Keep last 10-15 commands in session_log.txt
- Update current session summary with major changes
- Include enough context to recover from overflow
- Remove old entries when they become irrelevant
- Focus on actionable information for continuity
- **ALWAYS include comprehensive testing instructions**

## GIT WORKFLOW
- **NEVER automatically push changes** - wait for explicit user instructions
- Only commit and push when user says "push changes", "commit and push", or similar
- Always create backups before making changes
- Use meaningful commit messages
- Test syntax before committing

## DEVELOPMENT WORKFLOW
1. Make incremental changes (one small change at a time)
2. Test after each change
3. Check syntax after each modification
4. Commit working states frequently
5. Use meaningful commit messages
6. **Assess code quality** after significant changes
7. **Provide comprehensive testing instructions**
8. **Update relevant q/* files** with new learnings

## ERROR HANDLING
1. Add minimal debug statements only when debugging
2. Use backups to troubleshoot and revert if needed
3. Remove all debug statements before final commit
4. Check for syntax errors: unmatched braces, duplicate functions

## TESTING PROTOCOL
1. Provide exact testing steps to user
2. Wait for user confirmation before proceeding
3. Fix issues immediately when reported
4. Test in browser console for JavaScript errors
5. **Include comprehensive test scenarios** in session_log.txt

## CODE QUALITY
- Write minimal code that directly addresses requirements
- Avoid verbose implementations
- Follow existing code patterns in the project
- Maintain consistent indentation and formatting
- **Proactively identify refactoring opportunities**

## GAME MOVEMENT PATTERNS
- **Grid-based Movement**: Use timer accumulation for speed control in discrete grid games
- **Input Separation**: Keep input handling (direction changes) separate from movement execution
- **Speed Control Pattern**: 
  ```javascript
  entity.moveTimer += config.moveSpeed;
  if (entity.moveTimer >= 1) {
      entity.moveTimer = 0;
      // Execute movement
  }
  ```
- **Fractional Speeds**: Values like 0.33 create slower movement (moves every ~3 frames)

## GAME CONFIGURATION PATTERNS
- **Dual Configuration**: Games may have both hardcoded fallbacks AND external config files
- **Sync Requirement**: When updating game parameters, check both JS fallback values and JSON config files
- **Speed Relationships**: Maintain proportional relationships when adjusting speeds (player vs enemies)
- **Config Locations**: Check both `games/[name]/src/[name].js` and `games/[name]/config/[name].json`

**Example dual config pattern:**
```javascript
// In JS file (fallback)
pacmanConfig = { player: { moveSpeed: 0.66 } };

// In JSON file (primary)
"player": { "speed": 1.32 }
```
- **Asset paths**: Always use `./games/[gamename]/` prefix for all asset loading
- **Canvas setup**: Set both canvas properties AND CSS styles to same dimensions
- **Path testing**: Test both local development and GitHub Pages deployment
- **Asset loading**: Use relative paths, never absolute paths starting with `/`
- **Cache busting**: Add timestamp parameters for map/asset loading

**Example asset loading pattern:**
```javascript
const response = await fetch(`./games/mario/maps/${mapFile}?v=${Date.now()}`);
```

**Example canvas setup pattern:**
```javascript
canvas.width = 600;
canvas.height = 500;
canvas.style.width = '600px';
canvas.style.height = '500px';
canvas.style.display = 'block';
canvas.style.margin = '0 auto';
```
- Questions stored encrypted in questions.enc file (committed to git)
- questions.json is temporary decrypted file for editing (gitignored)
- encrypt-questions.js utility handles encryption/decryption (gitignored)
- Browser decrypts questions.enc at runtime using simpleDecrypt()
- Use ordered arrays: game N requires answer[N-1], shows question[N]
- All questions must have unique numeric answers
- Final question uses mathematical calculation with previous answers

## CONFIGURATION PROPERTY CONSISTENCY
- **Property Names**: Game code must use exact property names from config files
- **Common Issue**: Game code looking for `player.moveSpeed` when config has `player.speed`
- **Solution Pattern**: Always verify property names match between:
  - Game configuration JSON files (`games/[name]/config/[name].json`)
  - Game code that reads configuration (`games/[name]/src/[name].js`)
  - Fallback configuration objects in game code
- **Testing**: Use configuration UI to verify changes take effect in gameplay
- **Example Fix**: Pac-Man speed issue - changed `pacmanConfig.player.moveSpeed` to `pacmanConfig.player.speed`

## ENCRYPTION WORKFLOW
**To update questions:**
1. Run `node encrypt-questions.js` to create questions.json
2. Edit questions.json with new content
3. Run `node encrypt-questions.js` again to update questions.enc
4. Delete questions.json (automatically gitignored)
5. Test game loads questions properly
6. Commit and push questions.enc

**Security considerations:**
- Never commit questions.json to git
- Encryption key is in code but provides basic obfuscation
- Users browsing git only see encrypted questions.enc
- Game decrypts seamlessly at runtime
